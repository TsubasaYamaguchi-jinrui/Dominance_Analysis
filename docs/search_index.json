[["index.html", "Dominance Analysis Using R 本稿の目的", " Dominance Analysis Using R Tsubasa Yamaguchi 2024-02-02 本稿の目的 本稿は、順位に関する様々な指標の概要とRでの算出方法をまとめたものである。 主に扱う内容は以下のとおりである。 David’s Scoreの算出 steepnessの算出 linearity(\\(h&#39;\\)とtriangle transivity(\\(t_{tri}\\)))の算出 Elo-rating scoreの算出 なお、本稿の作成に使用したファイルやRのコードは筆者のGithubで全て閲覧できる。 "],["パッケージの読み込み.html", "0. パッケージの読み込み", " 0. パッケージの読み込み 指標の算出には、Eloratingパッケージ(Neumann and Kulik 2020)を用いる。 使い方については、こちらやこちらを参照。 library(EloRating) library(tidyverse) References "],["davids-scoreの算出.html", "1. David’s Scoreの算出 1.1 David’s Scoreとは 1.2 DSの定義 1.3 Normalized David’s Scoreの定義 1.4 Rでの算出方法", " 1. David’s Scoreの算出 1.1 David’s Scoreとは David’s Score(以下、DS)は、個体間の相対的なdominanceの差の違いを考慮して順位を算出してくれる指標である。一般的には個体の順位を高い方から順に1位, 2位, 3位, …と等間隔に割り振っていくため、1位 vs 2位と2位 vs 3位の間のdominanceの差が同じとみなされる。一方で、DSはその値の差が大きい個体間ほど、dominanceに差があることを表すことができる。 例えば、A, B, Cという個体のDSがそれぞれ2, 4, 7とすると、AとBの間のdominanceの差はBとCの差よりも小さいことになる。なお、DSは値が高い個体ほど順位が高いことを表す。 1.2 DSの定義 個体\\(i\\)の個体\\(j\\)に対する勝率を\\(P_{ij} = s_{ij}/n_{ij}\\)、敗率を\\(\\; P_{ji} = 1-P_{ij}\\)とするとき(ただし、\\(n_{ij}\\): 全敵対的交渉数, \\(s_{ij}\\): \\(i\\)が\\(j\\)に勝った回数)、個体\\(i\\)について\\(w_i, w2_i, l_i, l2_i\\)を以下のように定義する(\\(N\\)は個体数)。 \\[ \\begin{aligned} w_i &amp;= \\sum_{j=1}^{N} P_{ij} \\;\\; (j \\neq i) \\;\\; \\text{(個体}i\\text{の勝率の合計)}\\\\ w_{2i} &amp;= \\sum_{j=1}^{N} w_jP_{ij} \\;\\; (j \\neq i) \\;\\; \\text{(個体}j\\text{の}w_j\\text{で重みづけした個体}i\\text{の勝率の合計)}\\\\ l_i &amp;= \\sum_{j=1}^{N} P_{ji} \\;\\; (j \\neq i) \\;\\; \\text{(個体}i\\text{の敗率の合計)}\\\\ l_{2i} &amp;= \\sum_{j=1}^{N} l_jP_{ji} \\;\\; (j \\neq i) \\;\\; \\text{(個体}j\\text{の}l_j\\text{で重みづけした個体}i\\text{の敗率の合計)}\\\\ \\end{aligned} \\] このとき、個体\\(i\\)のDS(\\(DS_i\\))は以下のように定義される。 \\[ DS_i = w_i + w_{2i} - l_i - l_{2i} \\] なお、個体ごとの敵対的交渉(\\(n_ij\\))の試行数の違いを考慮するため、\\(P_{ij}\\)のかわりに以下の\\(D_{ij}\\)を、\\(P_{ji}\\)の代わりに\\(D_{ji} = 1- D_{ij}\\)用いてDSの算出を算出することもある。詳細は De Vries et al. (2006) を参照。 De Vries et al. (2006) では\\(D_{ij}\\)を使う方法が推奨されているようだが、十分に試行数がある場合には\\(P_{ij}\\)を使う方がいいと書いてある論文もあるようだ(Balasubramaniam et al. 2012)。 \\[ D_ij = P_{ij} - \\{(P_{ij}-0.5)/(n_{ij}+1)\\} \\] 1.3 Normalized David’s Scoreの定義 DSを算出する際には、steepness(後述)を算出する際にその値が0から1におさまるように標準化することが多い。これをNormalized David’s Score(以下、nDS)という(De Vries et al. 2006)。nDSは以下の式で計算される。これによって、nDSは0から\\(N-1\\)の間に収まる。 \\[ nDS_i = \\{DS_i + N(N-1)/2\\}/N \\] 1.4 Rでの算出方法 それではRでnDSの算出を行う。本稿では、 Vervaecke et al. (2007) に載っている馬の攻撃交渉の勝敗データを用いる。データはdata frameではなく、matrix(隣接行列)として読み込む必要があるので、csvファイルなどから読み込むときは必要に応じてas.matrix()でmatrix化する必要がある。 Rで直接マトリックスを作成する場合 mat &lt;- matrix(c(0,58,50,61,32,37,29,39,25,8,0,22,22,9,27,20,10,48, 3,3,0,19,29,12,13,19,8,5,8,9,0,33,38,35,32,57, 4,7,9,1,0,28,26,16,23,4,3,0,0,6,0,7,6,12, 2,0,4,1,4,4,0,5,3,0,2,1,1,5,8,3,0,10,3,1,3,0,0,4,1,2,0), nrow=9,byrow=TRUE) individuals &lt;- c(&quot;V&quot;,&quot;VS&quot;,&quot;B&quot;,&quot;FJ&quot;,&quot;PR&quot;,&quot;VB&quot;,&quot;TOR&quot;,&quot;MU&quot;,&quot;ZV&quot;) %&gt;% as.character() ##列名と行名を追加 colnames(mat) &lt;- individuals rownames(mat) &lt;- individuals mat ## V VS B FJ PR VB TOR MU ZV ## V 0 58 50 61 32 37 29 39 25 ## VS 8 0 22 22 9 27 20 10 48 ## B 3 3 0 19 29 12 13 19 8 ## FJ 5 8 9 0 33 38 35 32 57 ## PR 4 7 9 1 0 28 26 16 23 ## VB 4 3 0 0 6 0 7 6 12 ## TOR 2 0 4 1 4 4 0 5 3 ## MU 0 2 1 1 5 8 3 0 10 ## ZV 3 1 3 0 0 4 1 2 0 csvファイルから読みこむ場合 mat2 &lt;- read.csv(&quot;matrix.csv&quot;, row.names = 1) %&gt;% ## matrix形式に変換 as.matrix() それでは、算出する。EloRatingパッケージのDS関数を用い、prop =でPijかDijを指定する。 結果を確認すると、\\(P_{ij}\\)と\\(D_{ij}\\)を用いた場合で微妙に値が異なることが分かる。 \\(P_{ij}\\)を用いた場合 nDS_p &lt;- EloRating::DS(mat, prop = &quot;Pij&quot;) nDS_p \\(D_{ij}\\)を用いた場合 nDS_d &lt;- EloRating::DS(mat, prop = &quot;Dij&quot;) nDS_d References "],["steepnessの算出.html", "2. Steepnessの算出 2.1 Steepnessとは 2.2 Rでの算出方法", " 2. Steepnessの算出 2.1 Steepnessとは 続いて、順位序列のsteepnessを算出する。 steepnessは順位序列の厳しさを表し、例えば専制的な種ほどその値は高くなるとされる(Balasubramaniam et al. 2012)。X軸に順位が高い個体から名前を並べ、Y軸にnDSをプロットするとき、その回帰直線の傾きの絶対値がsteepnessとなる。0から1の値を取り、1に近づくほどsteepnessが高いことを示す。 単回帰分析を行ってやれば、steepness(=傾き)は算出できる。 今回の例では、傾きは約0.7421となることがわかる。 ## 単回帰分析 r &lt;- lm(data= nDS_d2, normDS~x) ## 傾きの絶対値 abs(r$coefficients[[2]]) ## [1] 0.7420538 2.2 Rでの算出方法 EloRatingパッケージのsteepness関数を用いることで、回帰分析をしなくてもsteepnessを算出することができる。Dij = TRUEをすると\\(D_{ij}\\)を用いたnDSを、Dij = FALSEをすると\\(P_{ij}\\)を用いたnDSを用いてsteepnessを算出する。 stp &lt;- EloRating::steepness(mat, Dij = TRUE) stp ## steep expected p nrand ## 0.7420538 NA NA 0.0000000 個体の勝敗がランダムに決まるときに比べて、steepnessが有意に高いかを検定することもできる(De Vries et al. 2006)。検定をする場合、ランダム化を行う回数をnrand =で指定する。今回の場合、\\(p &lt; 0.001\\)となり、有意であることが分かった。 EloRating::steepness(mat, Dij = TRUE, nrand = 10000) ## steep expected p nrand ## 7.420538e-01 3.004903e-01 1.000000e-04 1.000000e+04 returnfig = TRUEとすると、ランダムに勝敗が決まる場合のsteepnessの分布(extected)と実際のsteepnessの値(expected)をプロットできる。 EloRating::steepness(mat, Dij = TRUE, nrand = 10000, returnfig = TRUE) ## steep expected p nrand ## 7.420538e-01 3.013294e-01 1.000000e-04 1.000000e+04 References "],["linearityを表す指標の算出.html", "3. Linearityを表す指標の算出 3.1 Linearityとは 3.2 ランダウのhとh’ 3.3 triangle transitivity", " 3. Linearityを表す指標の算出 3.1 Linearityとは Linearityは順位序列がどの程度直線的かを示す指標である。直線的とは、順位序列に三すくみのような関係がないことを指す。 linearityの指標としては、ケンドールの\\(K\\)(Kendall’s \\(K\\))とランダウの\\(h\\)(Landau’s \\(h\\))を修正したもの(\\(h&#39;\\))がよく用いられてきた(De Vries 1995)。また、近年これらに変わる指標として、triangle transitivity(\\(t_{tri}\\))が提案されている(Shizuka and McDonald 2012)。 本稿では、これらのうち\\(h&#39;\\)と\\(t_{tri}\\)の解説を行う。 3.2 ランダウのhとh’ 3.2.1 指標の概要 ランダウの\\(h\\)(Landau 1951)は、個体間のdominanceのばらつきに着目した指標である。 算出に際しては、まず個体間の勝敗データに基づいて、もし個体\\(i\\)が個体\\(j\\)に対して勝ち越しているときは\\(X_{ij} = 1, X_{ji} = 0\\)となるような隣接行列を考える。なお、勝敗数が同じ場合は\\(X_{ij} = X_{ji} = 0.5\\)とする。 例えば、隣接行列は以下のようになる。 mat3 &lt;- read.csv(&quot;matrix2.csv&quot;, row.names = 1) %&gt;% ## matrix形式に変換 as.matrix() mat3 ## A B C D E F G H I ## A 0.0 0.5 1 1.0 1.0 1 1.0 1 1 ## B 0.5 0.0 1 1.0 1.0 1 1.0 1 1 ## C 0.0 0.0 0 1.0 0.0 1 1.0 1 1 ## D 0.0 0.0 0 0.0 0.5 1 0.0 1 1 ## E 0.0 0.0 1 0.5 0.0 0 0.5 1 1 ## F 0.0 0.0 0 0.0 1.0 0 1.0 0 1 ## G 0.0 0.0 0 1.0 0.5 0 0.0 1 1 ## H 0.0 0.0 0 0.0 0.0 1 0.0 0 0 ## I 0.0 0.0 0 0.0 0.0 0 0.0 1 0 ここで、各個体について行の値を合計したものを\\(S_i\\)(i = 1,2,,N)とする(\\(N\\)は個体数)。例えば、先ほどの隣接行列で個体\\(C\\)の\\(S_i\\)は\\(0 + 0+0+1+0+1+1+1+1 = 4\\)となる。このとき、ランダウの\\(h\\)は以下の式で算出される。 \\[ h = \\frac{12}{N^3 - N} \\Sigma_{i = 1}^N \\Bigl(S_i - (N-1)/2 \\Bigl) \\] しかし、動物の社会では個体間の敵対的な交渉が一度も確認されないことがよくある。例えば、以下の隣接行列では個体\\(B\\)と\\(F\\)、個体\\(A\\)と\\(I\\)、個体\\(C\\)と\\(I\\)は交渉が見られていない(RではNAで表されている)。 mat4 &lt;- read.csv(&quot;matrix3.csv&quot;, row.names = 1) %&gt;% ## matrix形式に変換 as.matrix() mat4 ## A B C D E F G H I ## A 0.0 0.5 1 1.0 1.0 1 1.0 1 NA ## B 0.5 0.0 1 1.0 1.0 NA 1.0 1 1 ## C 0.0 0.0 0 1.0 0.0 1 1.0 1 NA ## D 0.0 0.0 0 0.0 0.5 1 0.0 1 1 ## E 0.0 0.0 1 0.5 0.0 0 0.5 1 1 ## F 0.0 NA 0 0.0 1.0 0 1.0 0 1 ## G 0.0 0.0 0 1.0 0.5 0 0.0 1 1 ## H 0.0 0.0 0 0.0 0.0 1 0.0 0 0 ## I NA 0.0 NA 0.0 0.0 0 0.0 1 0 このように交渉がないダイアッドがあるとき、ランダウの\\(h\\)は直線性を過小評価してしまう(De Vries 1995)。そこで考え出されたのが\\(h&#39;\\)である。 \\(h&#39;\\)の算出の際には、交渉が見られなかった個体の勝敗に0と1をランダムに割り当てて\\(h\\)を計算する。これを10000回繰り返し、算出された\\(h\\)の平均をとったものが\\(h&#39;\\)である。\\(h&#39;\\)の期待値は以下の式のようになる(De Vries 1995)。なお、\\(u\\)は交渉が見られなかったダイアッドの数である。 \\[ h&#39; = h + \\frac{6}{N^3 - N} \\times u \\] 3.2.2 Rでの算出方法と検定 Rでは、EloRatingパッケージのh.index関数を用いて算出できる。このとき、関数に入れる隣接行列は上記で見たような1と0波で表される隣接行列でなくてもよい。例えば、前章まで使用していたデータmatを用いると以下のように算出できる。 h indexがランダウの\\(h\\)を、h' indexが\\(h&#39;\\)を表す。この隣接行列では交渉が見られなかったダイアッドはなかったので、いずれも同じ値になる。また、勝敗がランダムに決まるときのlinearity(extected h)に比べて実際のlinearityが有意に高いかという検定をした際の\\(p\\)値がp rightである。今回は\\(p = 0.001\\)なので有意に高いということになる。検定の際のランダム化の回数はloop =で指定する。検定の詳細については、 De Vries (1995) を参照。 EloRating::h.index(mat, loops = 1000) 交渉のないダイアッドがあると\\(h\\)と\\(h&#39;\\)の値は違くなる。例えば、先ほどの隣接行列(mat4)では以下のようになる。なお、算出の際には交渉がなかったダイアッドに対応する値はいずれも0としておく必要がある。tied/unknownで示されているのが、交渉のなかったダイアッドの数である。 ## 交渉のないところは0にする mat4[is.na(mat4)] &lt;- 0 EloRating::h.index(mat4, loops = 1000) 3.3 triangle transitivity 3.3.1 指標の概要 \\(h&#39;\\)の算出の際には、交渉が見られなかったダイアッドにランダムに勝敗を割り当てて指標を算出した。しかし、実際の動物の社会交渉では、交渉が生じない理由には様々なものが考えられる(e.g., 空間的隔離がある、避けている、観察時間の問題など)(Shizuka and McDonald 2012)。\\(h&#39;\\)のように人為的に値を割り当てる方法はこれらを区別しておらず、その結果指標にバイアスが生じる可能性がある。シミュレーションの研究から、\\(h&#39;\\)は特に個体数が多いときには直線性を過小評価してしまうことが分かっている(Shizuka and McDonald 2012)。 そこで考案されたのが、triangle transitivity(\\(t_{tri}\\))という指標である(Shizuka and McDonald 2012)。3者間の優劣関係は、全てのダイアッド間に交渉があるとき”transitive”か”cycle”のいずれかに分類できる(勝敗数が同じダイアッドがある場合は除く)。なお、図中で例えば\\(A \\rightarrow B\\)のときは\\(A\\)が\\(B\\)に勝ち越していることを示している。 “Transitive”な場合は、いわば\\(A &gt;B, B&gt;C\\)ならば\\(A&gt;C\\)の状況であり、3者間の優劣関係が直線的であるときである(図1)。一方で、“cycle”な場合はじゃんけんの様に三すくみが生じている状況である。 Figure 1: ‘Transitive’と’Cycle’ \\(t_{tri}\\)は簡単に言えば、“cycle”な関係に比べて”transitive”な関係がどのくらい多いかをもとに直線性を算出する指標である。\\(t_{tri}\\)の算出の際、勝敗数が同じダイアッドがない場合には、まず以下の式で\\(P_t\\)を求める。\\(N_t\\)は”transitive”な3者間の関係の数を、\\(N_c\\)は”cycle”な3者間の関係の数を表す。 \\[ P_t = \\frac{N_{t}}{N_t + N_c} \\] 勝敗の数が同じ(= 双方向的な)ダイアッドがあるときには、「3者間の関係が”transitive”になる可能性で重みづけた値(\\(w_u\\))」を用いる。図2はすべての3者間関係の\\(w_u\\)を示している。なお、両方向に矢印がある場合は、勝敗数が同じ双方向的な関係であったことを、矢印がない場合は交渉が見られなかったことを示す。 双方向的な関係がない場合には、\\(w_u\\)は”transitive”ならば1、それ以外は0になる。一方で、双方向的な関係を含む場合は、いずれの個体も優位になる(= 勝ち越す)可能性が0.5であると考えて3者間関係が”transitive”になる確率を\\(w_u\\)とする。例えば、図中の120Cは下にある矢印が右向きならば”transitive”だが、左向きならば”cycle”なので\\(w_u = 0.5\\)となる。一方で、210は双方向な関係が2つあり、考えうる4通りのうち3通りで”transitive”になるので、\\(w_u = 0.75\\)となる。 Figure 2: ’transitive’になる可能性の重み。Shizuka &amp; McDonald (2012) から引用。 このとき、\\(P_t\\)は以下のように計算する。なお、\\(N_{triangles}\\)は全ての3者間関係の数(ダイアッド間に交渉がないものを含む場合は除く)、\\(T_u\\)はそれぞれの3者間関係のタイプ(図2のTriad type)の数を表す。 \\[ P_t = \\frac{\\Sigma_{u} w_u \\times T_u}{N_{triangles}} \\] 個体間の優劣関係がランダムに決まるとき、\\(P_t\\)の期待値は0.75になることが分かっている(Shizuka and McDonald 2012)。そこで、\\(t_{tri}\\)は最大値が1になるように以下のように算出する(\\(P_t \\le 1\\)のため)。\\(t_{tri}\\)は理論上負の値になることはあるが、実際のデータをもとに算出した場合、負の値をとることは稀であることが分かっている(Shizuka and McDonald 2012) \\[ t_{tri} = 4(P_t - 0.75) \\] \\(t_{tri}\\)は\\(h&#39;\\)とは異なり、個体数が増加したり交渉のないダイアッドが増えたりしてもバイアスが生じないことが分かっている(Shizuka and McDonald 2012)。 3.3.2 Rでの算出方法と検定 RではEloRatingパッケージのtransitivity関数で求めることができる。この関数では、\\(t_{tri}\\)が個体の勝敗がランダムに決まる場合と比べて有意に高いかを検定することもできる。検定方法については、 Shizuka and McDonald (2012) を参照。runs =で検定でランダム化を行う回数を指定する。 例えば、前章から用いている隣接行列matを用いて算出すると以下のようになる。Ptが\\(P_t\\)を、ttriが\\(t_{tri}\\)を、pが\\(p\\)値を表している。\\(h&#39;\\)よりも値が若干高いことが分かる。 EloRating::transitivity(mat, runs = 5000) ## Pt ttri p runs ## 0.988 0.952 0.000 5000.000 交渉が見られないダイアッドを含むmat4で算出すると以下のようになる。やはり\\(h&#39;\\)よりも値が若干高い。 EloRating::transitivity(mat4, runs = 5000) ## Pt ttri p runs ## 0.891 0.565 0.023 5000.000 References "],["elo-ratingの算出.html", "4. Elo-ratingの算出 4.1 Elo-ratingとは 4.2 Rを用いた算出と可視化", " 4. Elo-ratingの算出 4.1 Elo-ratingとは Elo-ratingとは、各個体の相対的な強さを表す指標であり、そのときどきの勝敗によって常に変動する。主にサッカーやチェス、将棋などの競技で用いられているが、近年霊長類学を含む動物行動学の分野でもよく使われるようになっている(Newton-Fisher 2017; Ballesta et al. 2021; Neumann and Fischer 2023; Jarvey et al. 2024)。時系列的に指標の変化を調べることができ、交渉結果によって指標が随時更新されていくという点で他の順位関連指標(e.g., David’s score)とは異なる(cf. Albers and Vries 2001)。 Elo-ratingでは、交渉のたびに交渉前のレーティングから予想される勝利確率と実際の交渉結果を比較し、これらがどの程度違うかによってレーティングを更新していく。具体的には、個体\\(A\\)と\\(B\\)のレーティングを\\(R_A, R_B\\)、個体\\(A\\)が\\(B\\)に勝つ確率を\\(p_{AB}\\)とするとき、交渉後のレーティング(\\(R_{Anew}, R_{Bnew}\\))は以下のように変化する(Neumann et al. 2011)。なお、\\(k\\)は定数で自由に設定できる。\\(k\\)が大きいほど1回の交渉がレーティングに与える影響が大きくなる。 Aが勝った場合 \\[ R_{Anew} = R_A + (1-p_{AB})\\times k\\\\ R_{Bnew} = R_B - (1-p_{AB})\\times k \\] Bが勝った場合 \\[ R_{Anew} = R_A - p_{AB}\\times k\\\\ R_{Bnew} = R_B + p_{AB}\\times k \\] なお、交渉前の勝利確率\\(p_{AB}\\)は一般に以下の式で計算される(Wikipediaより)。 \\[ p_{AB} = \\frac{1}{10^{(R_B - R_A)/400} + 1} \\] ただし、勝利確率をどのように算出するかについては、まだコンセンサスが得られておらず、様々な方法があるようだ(Neumann and Fischer 2023)。霊長類の研究(Franz et al. 2015; Goffe et al. 2018)では、交渉前に個体\\(A\\)が\\(B\\)に勝つ確率\\(P_{AB}\\)を以下のように定義している。なお、 Franz et al. (2015) では\\(\\delta = 0.01\\)、 Goffe et al. (2018) では\\(\\delta = 1\\)としている。 \\[ P_{AB} = \\frac{1}{1 + exp(- \\delta(R_A - R_B))} \\] 4.2 Rを用いた算出と可視化 4.2.1 Elo-ratingの算出 4.2.1.1 交渉の種類を考慮しない場合 EloRatingパッケージでは、以下のような日付と勝敗が示されたデータを用いてElo-ratingを算出する。 data(adv) adv Elo-ratingはelo.seq関数を用いて算出できる。winner =に勝者の値をおさめたベクトルを、loser =に敗者の値をおさめたベクトルを、Dateで日付をおさめたベクトルを、k =で\\(k\\)を指定する。その他の引数については、?elo.seqを参照。 res &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date, k = 100) \\(k\\)の値については、optimizek関数を用いて、実際の交渉データに最もよく符合するような\\(k\\)を最尤法で推定することもできる1。krange =で想定する\\(k\\)の範囲を、resolution =で指定した範囲を何等分した値を用いて推定を行うかを指定する。今回の場合は、最尤推定値はk = 252.6982になるようだ(loglikはそのときの対数尤度)。 ml_z &lt;- optimizek(res, krange = c(2,500), resolution = 50000) ml_z$best この値を用いてもう一度Elo-ratingを算出すると以下のようになる。 res_opt &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date, k = ml_z$best$k) summary関数で日付の範囲や交渉の数などの基本情報を確認できる。 summary(res_opt) ## Elo ratings from 7 individuals ## total (mean/median) number of interactions: 33 (9.4/9) ## range of interactions: 7 - 11 ## date range: 2010-01-01 - 2010-02-02 ## startvalue: 1000 ## uppon arrival treatment: average ## k: 252.698213964279 ## proportion of draws in the data set: 0 Elo-ratingの時系列的変化はeloplot関数で以下のように描画できる(図3)。from =とto =で日付の範囲を、ids =で描画したい個体名を指定する。 eloplot(res_opt, from = &quot;2010-01-01&quot;, to = &quot;2010-02-02&quot;, ids = &quot;all&quot;) Figure 3: 交渉の種類を考慮しない場合のElo-rating 4.2.1.2 交渉の種類を考慮する場合 交渉の種類が複数あり、それぞれの激しさが異なるようなとき(例えば、サプラント、威嚇、物理的攻撃など)、それぞれについて異なる\\(k\\)の値を付すこともできる(Newton-Fisher 2017)。例えば、以下のadv2というデータでは、intensity列に各交渉で見られた敵対的交渉が2種類記録されている(displaceかfight)。 data(adv2) adv2 displaceなら\\(k = 50\\)、fightなら\\(k = 200\\)の様にlist形式でそれぞれの\\(k\\)を書いたものを、elo.seq関数のk =で指定する。また、intensity =に交渉の種類を示したベクトルを指定する。 myk &lt;- list(displace = 50, fight = 200) res_int &lt;- elo.seq(winner = adv2$winner, loser = adv2$loser, Date = adv2$Date, k = myk, intensity = adv2$intensity) この場合も同様に、最尤法を利用して実際の交渉データに最もよく符合するような\\(k\\)を推定できる。krange =でlist形式でそれぞれの種類ごとに想定する\\(k\\)の範囲を、itype =でそれぞれの交渉の種類の名前のベクトルを指定する。 今回の場合は、displaceのときは\\(k = 186.0861\\)、fightのときは\\(k = 477.9279\\)と推定された。 ml_z2 &lt;- optimizek(res_int, krange = list(displace = c(10,500), fight = c(10,500)), resolution = 1000, itype = adv2$intensity) ml_z2$best この値を用いてもう一度Elo-ratingを算出すると以下のようになる。 myk2 &lt;- list(displace = ml_z2$best$displace, fight = ml_z2$best$fight) res_int_opt &lt;- elo.seq(winner = adv2$winner, loser = adv2$loser, Date = adv2$Date, k = myk2, intensity = adv2$intensity) summary関数で日付の範囲や交渉の数などの基本情報を確認できる。 summary(res_int_opt) ## Elo ratings from 7 individuals ## total (mean/median) number of interactions: 33 (9.4/9) ## range of interactions: 7 - 11 ## date range: 2010-01-01 - 2010-02-02 ## startvalue: 1000 ## uppon arrival treatment: average ## k: custom values ranging between 186.086086086086 and 477.927927927928 ## proportion of draws in the data set: 0 Elo-ratingの時系列的変化をeloplot関数で描画すると以下のようになる(図4)。 eloplot(res_int_opt, from = &quot;2010-01-01&quot;, to = &quot;2010-02-02&quot;, ids = &quot;all&quot;) Figure 4: 交渉の種類を考慮した場合のElo-rating 4.2.1.3 事前情報を考慮する場合 Elo-ratingは、データ収集の開始時点では全ての個体のレーティングが等しいと仮定され、それを実際の交渉の結果によって更新していく。しかし、これは集団が新たに形成された場合は適切であるが、集団がデータ収集前から存在している場合には妥当ではない(Newton-Fisher 2017)。また、Elo-ratingが実際の優劣関係と一致するためには、交渉数が十分に蓄積する時点までburn-in期間と呼ばれる期間が必要である(Albers and Vries 2001; Neumann et al. 2011)。この期間のElo-ratingは信頼性が低く、分析などに使用することができない(Newton-Fisher 2017)。 これらの問題を解決するため、 Newton-Fisher (2017) は事前に個体間の優劣関係についてわかっている情報をElo-ratingの算出に用いることを提案している。この方法を用いれば、データ収集の開始時点から個体間のレーティングが全く同じになることはなく、またburn-in期間を短縮できる可能性がある。 事前に個体間の優劣関係(e.g., 順位など)が分かっているとき、開始時点の個体\\(i\\)のElo-ratingは以下のように定義される(Newton-Fisher 2017)。\\(S_e\\)は事前の情報がない場合の開始時点のレーティング(デフォルトは1000)、\\(x_r\\)は事前情報で分かっている全個体の順位の中央値、\\(S_{ri}\\)は事前情報による個体\\(i\\)の順位である2。\\(k\\)は前節までと同じで、\\(l_r\\)は事前情報による順位をどの程度反映させるかを決める定数で、0から1の値を指定できる。 \\[ E_i = S_e + [(x_r - S_{ri})\\times k \\times S_{ri}^{-l_r}] \\] 例えば、事前に順位(1位, 2位, …, 10位)の情報があるとき、\\(l_r\\)の値による開始時点のレーティングは以下のような関係になる。 Figure 5: lrによる開始時点のレーティング。 それでは、Rを用いて算出してみよう。以下のように事前に順位(e.g., 1位, 2位, …)が分かっているとする。 myranks &lt;- c(1,2,3,4,5,6,7) names(myranks) &lt;- c(&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;, &quot;e&quot;, &quot;g&quot;,&quot;a&quot;) myranks ## b c d f e g a ## 1 2 3 4 5 6 7 このとき、開始時点のレーティングはbreatestartvalues関数で以下のように算出できる。shape =で\\(\\delta\\)を、startvalue =で\\(S_e\\)を、k =で\\(k\\)を指定する。 mystart &lt;- createstartvalues(myranks, shape = 0.3, startvalue = 1000, k = 100) mystart$res ## b c d f e g a ## 1273 1136 1045 973 911 856 806 これを事前情報として用いたElo-ratingは以下のように算出する。startvalue =で先ほど算出したレーティングのベクトルを指定する。 res_prior &lt;- elo.seq(winner= adv2$winner, loser= adv2$loser, Date = adv2$Date, startvalue = mystart$res) Elo-ratingの時系列的変化をeloplot関数で描画すると以下のようになる(図6)。事前情報がなかった場合(図3と図4)に比べてレーティングが安定するのが早く、burn-in期間が短くなっていることが分かる。 eloplot(res_prior, from = &quot;2010-01-01&quot;, to = &quot;2010-02-02&quot;, ids = &quot;all&quot;) Figure 6: 事前情報(数字の順位)を考慮した場合のElo-rating 順位が以下のようにカテゴリでしかわかっていない場合でも、事前情報を考慮して算出を行うことができる(ただし、現時点では4カテゴリのみ可能)。順位の情報はlist形式で作成する。4カテゴリ未満の場合、使っていないクラスの個体名はNULLとする。 myrank_cat &lt;- list(alpha = &quot;a&quot;, high = c(&quot;b&quot;,&quot;c&quot;), mid = c(&quot;d&quot;, &quot;e&quot;), low = c(&quot;f&quot;, &quot;g&quot;)) ## 4カテゴリ未満の場合 # myrank_cat &lt;- list(high = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), mid = NULL, # low = c(&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;), superlow = NULL) myrank_cat ## $alpha ## [1] &quot;a&quot; ## ## $high ## [1] &quot;b&quot; &quot;c&quot; ## ## $mid ## [1] &quot;d&quot; &quot;e&quot; ## ## $low ## [1] &quot;f&quot; &quot;g&quot; このとき、開始時点のレーティングはbreatestartvalues関数で以下のように算出できる。rankclasses =で先ほど作成したlistを指定する。 mystart_cat &lt;- createstartvalues(rankclasses = myrank_cat, shape = 0.3, startvalue = 1000, k = 100) mystart_cat$res ## a b c d e f g ## 1202 1100 1100 952 952 846 846 これを事前情報として用いたElo-ratingは以下のように算出する。startvalue =で先ほど算出したレーティングのベクトルを指定する。 res_prior_cat &lt;- elo.seq(winner= adv2$winner, loser= adv2$loser, Date = adv2$Date, startvalue = mystart_cat$res) Elo-ratingの時系列的変化をeloplot関数で描画すると以下のようになる(図7)。やはり事前情報がなかった場合(図3と図4)に比べてレーティングが安定するのが早く、burn-in期間が短くなっていることが分かる。 eloplot(res_prior_cat, from = &quot;2010-01-01&quot;, to = &quot;2010-02-02&quot;, ids = &quot;all&quot;) Figure 7: 事前情報(順位カテゴリ)を考慮した場合のElo-rating 4.2.2 Elo-ratingの抽出 ある日付におけるElo-ratingはextract_elo関数で以下のように求められる。extractdate =で日付を、IDs =で値を求めたい個体名を指定する(指定しなければ全個体について出力する)。 extract_elo(res_int_opt, extractdate = &quot;2010-01-28&quot;, IDs = c(&quot;b&quot;,&quot;d&quot;,&quot;g&quot;)) ## d b g ## 1265 1187 747 日付を指定しなければ最終日のElo-ratingが求められる。 extract_elo(res_int_opt) ## b f d c e g a ## 1305 1272 1267 1167 1058 624 307 複数の日のデータを一度に取得したい場合は、extradate =で日付を表すベクトルを、IDs =で個体名を表すベクトルを指定する。例えば、元データadvに勝者(winner)と 敗者(loser)のElo-ratingを示す列を作成する場合は以下のようにする。 adv %&gt;% ## 勝者のElo-rating mutate(Rate_winner = extract_elo(res_int_opt, extractdate = adv2$Date, IDs = adv2$winner)) %&gt;% ## 敗者のElo-rating mutate(Rate_loser = extract_elo(res_int_opt, extractdate = adv2$Date, IDs = adv2$loser)) 新しく日付と個体名を含むデータフレームを作成し、そこに各個体のElo-ratingを表す列を作成するというようなこともできる。 ## 全ての日付と個体名の組み合わせを含むデータフレームを作成 all_combi &lt;- crossing(Date = unique(adv2$Date), ID = unique(c(adv2$winner, adv2$loser))) ## 各日・各個体のElo-ratingを算出 all_combi %&gt;% mutate(Elo_rating = extract_elo(res_int_opt, extractdate = all_combi$Date, IDs = all_combi$ID)) References "],["動作環境.html", "動作環境", " 動作環境 sessionInfo() ## R version 4.2.2 (2022-10-31 ucrt) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 22621) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Japanese_Japan.utf8 LC_CTYPE=Japanese_Japan.utf8 ## [3] LC_MONETARY=Japanese_Japan.utf8 LC_NUMERIC=C ## [5] LC_TIME=Japanese_Japan.utf8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] ggsci_2.9 patchwork_1.1.2 ggdag_0.2.7 ## [4] dagitty_0.3-1 lubridate_1.9.2 forcats_1.0.0 ## [7] stringr_1.5.1 dplyr_1.1.2 purrr_1.0.2 ## [10] readr_2.1.4 tidyr_1.3.1 tibble_3.2.1 ## [13] ggplot2_3.4.4 tidyverse_2.0.0 EloRating_0.46.11 ## [16] sna_2.7 network_1.18.0 statnet.common_4.7.0 ## [19] zoo_1.8-11 ## ## loaded via a namespace (and not attached): ## [1] viridis_0.6.4 sass_0.4.8 viridisLite_0.4.2 tidygraph_1.2.2 ## [5] jsonlite_1.8.8 splines_4.2.2 ggraph_2.1.0 bslib_0.6.1 ## [9] Rdpack_2.5 highr_0.10 yaml_2.3.7 ggrepel_0.9.2 ## [13] pillar_1.9.0 lattice_0.20-45 glue_1.6.2 digest_0.6.31 ## [17] rbibutils_2.2.15 polyclip_1.10-4 colorspace_2.0-3 htmltools_0.5.7 ## [21] Matrix_1.6-1 pkgconfig_2.0.3 bookdown_0.35 scales_1.3.0 ## [25] tweenr_2.0.2 tzdb_0.3.0 ggforce_0.4.1 timechange_0.1.1 ## [29] mgcv_1.9-1 generics_0.1.3 farver_2.1.1 cachem_1.0.8 ## [33] withr_3.0.0 cli_3.6.1 magrittr_2.0.3 evaluate_0.23 ## [37] fansi_1.0.3 nlme_3.1-160 MASS_7.3-58.1 tools_4.2.2 ## [41] hms_1.1.3 see_0.7.5.5 lifecycle_1.0.4 V8_4.2.2 ## [45] munsell_0.5.0 compiler_4.2.2 jquerylib_0.1.4 rlang_1.1.1 ## [49] grid_4.2.2 rstudioapi_0.15.0 igraph_1.3.5 labeling_0.4.3 ## [53] rmarkdown_2.25 boot_1.3-28 gtable_0.3.4 curl_4.3.3 ## [57] graphlayouts_1.0.0 R6_2.5.1 gridExtra_2.3 knitr_1.45 ## [61] fastmap_1.1.1 utf8_1.2.2 stringi_1.8.3 Rcpp_1.0.11 ## [65] vctrs_0.6.3 tidyselect_1.2.0 xfun_0.39 coda_0.19-4 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
